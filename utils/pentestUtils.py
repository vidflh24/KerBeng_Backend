import re
import ipaddress
import socket
import platform

# fcntl/struct are only available on Unix-like systems (used for interface lookup fallback)
try:
    import fcntl
    import struct
except Exception:
    fcntl = None
    struct = None

class PentestUtils:

    def __init__(self) -> None:
        pass
    
    @classmethod
    def extract_ip_addresses(self, input_string):
        # Regular expression to match IP addresses (IPv4) and subnet prefixes (optional)
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?\b'
        
        # Use re.findall to extract all IP addresses or IP with subnet from the input string
        matches = re.findall(ip_pattern, input_string)
        
        ip_list = []

        # Iterate over each match to check if it's an IP address or a network
        for match in matches:
            if '/' in match:
                # Handle the case where it's an IP network with a subnet
                try:
                    network = ipaddress.ip_network(match, strict=False)
                    # Expand all IP addresses in the subnet and add to the list
                    ip_list.extend([str(ip) for ip in network.hosts()])
                except ValueError:
                    print(f"Invalid IP network: {match}")
            else:
                # If it's just a single IP, add it directly to the list
                try:
                    ip = ipaddress.ip_address(match)
                    ip_list.append(str(ip))
                except ValueError:
                    print(f"Invalid IP address: {match}")

        return ip_list 
    
    @classmethod
    def isPrivateIP(self, ipString):
        try:
            # Parse the IP address
            ip = ipaddress.ip_address(ipString)
            # Check if the IP is private
            return ip.is_private # private is True
        except ValueError:
            print(f"Invalid IP address: {ipString}")
            return None

    @classmethod
    def getLocalIP(cls, iface: str | None = None, target: str | None = None, port: int = 80):
        """
        Determine a local IPv4 address.

        - If iface is provided: try to return the IPv4 address assigned to that interface.
          * On Unix: prefers 'netifaces' if available, otherwise uses ioctl fallback.
          * On other OSes: will only work if netifaces is installed, otherwise returns None.
        - Else if target is provided: create an UDP socket connected to target:port to determine
          the outbound local address used to reach that target (works cross-platform).
        - Else: connect to 1.1.1.1:80 to determine the default outbound local address.

        Returns: string IPv4 address, or None on error.
        """
        # If iface explicitly requested
        if iface:
            # Try using netifaces if available (more robust)
            try:
                import netifaces
                if iface not in netifaces.interfaces():
                    print(f"[DEBUG] interface '{iface}' not found by netifaces")
                    return None
                addrs = netifaces.ifaddresses(iface)
                # AF_INET gives IPv4 addresses
                inet = addrs.get(netifaces.AF_INET)
                if not inet:
                    print(f"[DEBUG] interface '{iface}' has no IPv4 address")
                    return None
                # take the first IPv4 address
                ip = inet[0].get('addr')
                return ip
            except Exception:
                # fallback to ioctl on Unix-like systems
                if fcntl and struct and platform.system() != 'Windows':
                    try:
                        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                        # iface name must be bytes, max 15 chars in C struct
                        iface_bytes = iface[:15].encode('utf-8')
                        packed = struct.pack('256s', iface_bytes)
                        SIOCGIFADDR = 0x8915  # Linux specific
                        res = fcntl.ioctl(s.fileno(), SIOCGIFADDR, packed)
                        ip = socket.inet_ntoa(res[20:24])
                        s.close()
                        return ip
                    except OSError as e:
                        print(f"[DEBUG] ioctl fallback failed for interface '{iface}': {e}")
                        return None
                else:
                    print("[DEBUG] netifaces not installed and ioctl not available on this platform.")
                    return None

        # If target provided (determine which local IP would be used to reach that target)
        if target:
            # Validate/normalize target (allow hostnames or IPs)
            try:
                # if it's an IP/net, try parsing; if hostname, skip parsing
                try:
                    # allow host:port style
                    if ':' in target and target.count(':') == 1 and not target.startswith('['):
                        host_part, maybe_port = target.rsplit(':', 1)
                        ipaddress.ip_address(host_part)
                        # if valid, keep host_part as target
                        target_host = host_part
                    else:
                        ipaddress.ip_address(target)
                        target_host = target
                except ValueError:
                    # not a pure IP â€” will try DNS resolution in socket.create_connection equivalent
                    target_host = target

                # Use UDP connect trick: no packets are sent but OS picks the route and local IP
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                # If target is hostname, let the socket resolve it (may raise)
                s.connect((target_host, port))
                local_ip = s.getsockname()[0]
                s.close()
                return local_ip
            except Exception as e:
                print(f"[DEBUG] failed to determine local IP for target '{target}': {e}")
                return None

        # Default behaviour: determine default outbound IP by connecting to a public IP (no data sent)
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            # 1.1.1.1 is Cloudflare DNS; port 80 chosen arbitrarily
            s.connect(("1.1.1.1", port))
            local_ip = s.getsockname()[0]
            s.close()
            print("[DEBUG] s.getsockname():", local_ip)
            return local_ip
        except Exception as e:
            print(f"[DEBUG] Error determining default local IP: {e}")
            return None
